<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Golf Course Mapper</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .input-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            margin: 10px auto;
            padding: 10px;
            box-sizing: border-box;
        }

        /* Style each input and button to scale properly */
        .input-container input[type="text"],
        .input-container select,
        .input-container button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            font-size: 14px;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .input-container button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }

        .input-container button:hover select:hover {
            background-color: #0056b3;
        }

        /* Make the map fill remaining space */
        #map {
            flex-grow: 1;
            /* Allows the map to take up the remaining space */
        }

        .track-me {
            display: flex;
            align-items: center;
            margin-left: 10px;
            /* Adds space between the button and the checkbox */
        }

        .track-me input[type="checkbox"] {
            margin-right: 5px;
            /* Adds space between the checkbox and the label text */
        }

        /* Responsive adjustments for small screens */
        @media (max-width: 1200px) {
            .input-container {
                display: flex;
                flex-direction: column;
                max-width: 90%;
                padding: 5px;
            }

            .input-container input[type="text"],
            button,
            select {
                padding: 8px;
                font-size: 14px;
            }

            .track-me {
                margin-left: 0;
                /* Reset margin on smaller screens */
                justify-content: center;
                /* Center the checkbox on smaller screens */
            }
        }


        .hole-number {
            background-color: yellow;
            /* Change background color for visibility */
            border: 2px solid green;
            /* Make the border more pronounced */
            border-radius: 5px;
            padding: 5px;
            /* Increase padding */
            text-align: center;
            font-size: 14px;
            /* Adjust font size */
            color: black;
            /* Ensure text is dark */
        }

        .hole-number-current {
            background-color: aquamarine;
        }
    </style>
</head>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="application-name" content="Golf Map" />
<meta name="apple-mobile-web-app-title" content="GolfMap" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />

<body>
    <div class="container">
        <form id="controls" class="input-container" onsubmit="findGolfCourse(); return false;">
            <input type="text" id="location" placeholder="Enter city, zipcode, course name. Or empty for nearby.">
            <select id="courseSelect" onchange="onSelectCourse()" disabled style="display: none;">
                <option value="" disabled selected>Select a golf course</option>
                <option value="China Creek">China Creek</option>
                <option value="River Valley">River Valley</option>
                <option value="Mountain View">Mountain View</option>
                <!-- Add more options as needed -->
            </select>
            <input type="text" id="courseName" style="display: none;" disabled> <!-- Initially hidden -->
            <button type="submit">Go</button>
            <label class="track-me">
                <input type="checkbox" id="trackMe"> Track Me
            </label>
        </form>
        <div id="map"></div>
    </div>


    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script>
        // Initialize map
        const map = L.map('map').setView([47.6104, -122.2007], 13);
        map.on('locationfound', onLocationFound);
        // Create street layer from OSM
        const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            tileSize: 256
        });

        // Add Esri satellite layer
        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 18,
            tileSize: 256
        });

        baseMaps = {
            "Street View": streetLayer,
            "Satellite View": satelliteLayer
        };

        L.control.layers(baseMaps).addTo(map);

        // Set the default layer
        streetLayer.addTo(map);


        // Initialize geocoder for location input
        const geocoder = L.Control.Geocoder.nominatim();

        // Create separate layer groups
        const userLayer = L.layerGroup().addTo(map); // For user location markers
        const golfCourseLayer = L.layerGroup().addTo(map); // For golf course markers
        const yardageLayer = L.layerGroup().addTo(map); // For lines between current location and green marker
        const courseSelect = document.getElementById('courseSelect');
        let multiCourseLayerGroups = {};

        let userMarker; // Store the user marker
        let watchId;
        let focusGreenMarker;

        //--- watch/track user location component

        function startTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(updatePosition, handleError, {
                    enableHighAccuracy: true,
                    maximumAge: 3000,
                    timeout: 5000
                });
            } else {
                alert("Geolocation is not supported by this browser.");
            }
        }

        function stopTracking() {
            if (navigator.geolocation && watchId) {
                navigator.geolocation.clearWatch(watchId);
                userLayer.clearLayers();
                userMarker = null;
                yardageLayer.clearLayers();
            }
        }

        function updatePosition(position) {
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;

            // Update the map with the user's location marker
            if (!userMarker) {
                userMarker = L.marker([latitude, longitude]).addTo(userLayer)
                    .bindPopup("You are here").openPopup();
            } else {
                userMarker.setLatLng([latitude, longitude]);
                drawYardage();
            }
            map.setView([latitude, longitude]); // Center the map on the user's location
        }

        function handleError(error) {
            console.error(`Error occurred: ${error.message}`);
        }

        function calculateMarkerDistanceInYards(marker1, marker2) {
            // Get coordinates of the two markers
            let latlng1 = marker1.getLatLng();
            let latlng2 = marker2.getLatLng();

            // Calculate distance in meters
            let distanceInMeters = latlng1.distanceTo(latlng2);

            // Convert meters to yards
            let distanceInYards = distanceInMeters * 1.09361;

            // Return the distance in yards
            return distanceInYards;
        }

        function drawYardage() {
            if (focusGreenMarker && userMarker) {
                const yardage = calculateMarkerDistanceInYards(focusGreenMarker, userMarker);
                userMarker.getPopup().setContent(yardage.toFixed(0) + " yards");
                yardageLayer.clearLayers();
                L.polyline([userMarker.getLatLng(), focusGreenMarker.getLatLng()], {
                    color: 'red',   // Color of the line
                    weight: 1,      // Thickness of the line
                    opacity: 0.7,   // Transparency of the line
                }).addTo(yardageLayer);
                userMarker.openPopup();
            }
        }

        document.getElementById("trackMe").addEventListener("change", function () {
            if (this.checked) {
                startTracking();
            } else {
                stopTracking();
            }
        });

        function addOptionToSelect(selectObj, newOptionValue) {
            // Create a new option element
            const newOption = document.createElement('option');
            newOption.value = newOptionValue; // Set the value
            newOption.textContent = newOptionValue; // Set the display text

            // Append the new option to the select element
            selectObj.appendChild(newOption);
        }

        function resetCourseSelect(selectObj) {
            // Clear all existing options
            selectObj.innerHTML = '';
            selectObj.style.display = 'none'; // Hides the select element
            selectObj.disabled = true;        // Disables the select element
        }

        function postLookupProcessCourseSelect(selectObj) {

            // Check if the select element has only one option that is "Default"
            if (selectObj.options.length === 1 && selectObj.options[0].textContent === 'Unnamed') {
                // Hide and disable the select element
                selectObj.style.display = 'none'; // Hides the select element
                selectObj.disabled = true;        // Disables the select element
            } else {
                // Show and enable the select element
                selectObj.style.display = 'block'; // Shows the select element
                selectObj.disabled = false;        // Enables the select element
            }
        }

        // Function to handle the selection event
        function onSelectCourse() {
            const courseSelect = document.getElementById('courseSelect');
            const selectedCourse = courseSelect.value;

            // Hide all sub LayerGroups
            for (const key in multiCourseLayerGroups) {
                if (multiCourseLayerGroups.hasOwnProperty(key)) {
                    multiCourseLayerGroups[key].removeFrom(golfCourseLayer);
                }
            }

            // Show the selected course's LayerGroup
            if (multiCourseLayerGroups[selectedCourse]) {
                multiCourseLayerGroups[selectedCourse].addTo(golfCourseLayer);
                const bounds = multiCourseLayerGroups[selectedCourse].getBounds();
                if (bounds.isValid()) {
                    // Fit the map view to the bounds of the layer group
                    map.fitBounds(bounds);
                }
            }
        }

        //---

        async function findGolfCourse() {
            const courseName = document.getElementById("courseName").value;
            const location = document.getElementById("location").value;
            golfCourseLayer.clearLayers();
            yardageLayer.clearLayers();
            resetCourseSelect(courseSelect);
            focusGreenMarker = null;

            if (location) {
                // Use geocoding to convert location input into bounding box
                await geocoder.geocode(location, (results) => queryForGolfCourses(results, courseName));
            } else {
                map.locate();
            }
        }

        function queryForGolfCourses(results, courseName) {
            if (results.length > 0) {
                const bbox = results[0].bbox;
                const south = bbox.getSouthWest().lat;
                const west = bbox.getSouthWest().lng;
                const north = bbox.getNorthEast().lat;
                const east = bbox.getNorthEast().lng;

                L.rectangle(bbox, {
                    color: "#ff7800",   // Border color
                    weight: 1,          // Border weight
                    fillOpacity: 0      // No fill color
                }).addTo(golfCourseLayer);

                map.fitBounds(bbox);

                // Construct Overpass API query
                const queryString = courseName ?
                    `nwr["golf:course:name"="${courseName}"](${south},${west},${north},${east});` :
                    `nwr["golf"="hole"](${south},${west},${north},${east});`;

                const overpassQuery = `
                        [out:json];
                        ${queryString}
                        // way(r)["golf"="fairway"];
                        // way(r)["golf"="green"];
                        out body;
                        >;
                        out skel qt;
                    `;

                // Fetch Overpass API results
                fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`)
                    .then(response => response.json())
                    .then(data => displayGolfCourse(data, bbox))
                    .catch(error => console.error("Overpass API error:", error));
            } else {
                alert("Location not found.");
            }
        }

        function displayGolfCourse(data, bounds) {
            // Create a node lookup table from all nodes in the response
            const nodeLookup = {};
            // Reset multi-course layergroup lookup so that i can look up layergroups by name
            multiCourseLayerGroups = {};
            data.elements.forEach((element) => {
                if (element.type === "node") {
                    nodeLookup[element.id] = [element.lon, element.lat];
                }
            });

            // Display fetched data on the map

            const greens = L.geoJSON(null, { style: { color: "darkgreen", fillOpacity: 0.4 } }).addTo(golfCourseLayer);

            // Array to hold all coordinates for bounding box calculation
            const allCoordinates = [];

            data.elements.forEach((element) => {
                if (element.type === "node") return;
                let holeCourseName = element.tags["golf:course:name"];
                if (!holeCourseName) holeCourseName = 'Unnamed';
                if (multiCourseLayerGroups[holeCourseName] == undefined) {
                    multiCourseLayerGroups[holeCourseName] = L.featureGroup();
                    multiCourseLayerGroups[holeCourseName].addTo(golfCourseLayer);
                    addOptionToSelect(courseSelect, holeCourseName);
                }
                // console.log(multiCourseLayerGroups);
                const fairways = L.geoJSON(null, { style: { color: "green" } }).addTo(multiCourseLayerGroups[holeCourseName]);
                const geojson = toGeoJSON(element, nodeLookup);
                if (element.tags["golf"] === "hole") {
                    fairways.addData(geojson);
                    // Add hole number overlay
                    const holeNumber = element.tags["ref"]; // Adjust based on the correct tag
                    const par = element.tags["par"]
                    const holeYardage = calculateLineStringLengthInYards(geojson);
                    if (holeNumber) {
                        const midpoint = getMidpoint(geojson.geometry.coordinates);
                        const marker = L.marker(midpoint, {
                            icon: L.divIcon({
                                className: 'hole-number',
                                html: holeNumber,
                                iconSize: [15, 15]
                            })
                        }).bindPopup("Par " + par + "<br>" + holeYardage.toFixed(0) + " yards").addTo(multiCourseLayerGroups[holeCourseName]);
                        marker.on('click', () => {
                            if (focusGreenMarker) {
                                // reset previous marker
                                let currentIcon = focusGreenMarker.getIcon();
                                currentIcon.options.className = 'hole-number';
                                focusGreenMarker.setIcon(currentIcon);
                            }
                            focusGreenMarker = marker;
                            // reset previous marker
                            let currentIcon = focusGreenMarker.getIcon();
                            currentIcon.options.className = 'hole-number hole-number-current';
                            focusGreenMarker.setIcon(currentIcon);
                            drawYardage();
                        });
                    }
                } else if (element.tags["golf"] === "green") {
                    greens.addData(geojson);
                }

                // Collect all coordinates for bounding box calculation
                geojson.geometry.coordinates.forEach(coord => {
                    allCoordinates.push(coord);
                });
            });

            postLookupProcessCourseSelect(courseSelect);

            // Calculate bounding box from all collected coordinates
            if (allCoordinates.length > 0) {
                const bounds = L.latLngBounds(allCoordinates.map(coord => [coord[1], coord[0]]));
                map.fitBounds(bounds);
                // map.locate();
            } else {
                alert("No ways found for the specified course.");
            }
        }

        function toGeoJSON(element, nodeLookup) {
            if (element.type === "way") {
                const coordinates = element.nodes
                    .map(nodeId => nodeLookup[nodeId]) // Map node IDs to [lon, lat] pairs
                    .filter(coord => coord); // Filter out any undefined entries

                // Only create a geoJSON object if we have valid coordinates
                if (coordinates.length > 0) {
                    return {
                        type: "Feature",
                        geometry: {
                            type: "LineString",
                            coordinates: coordinates
                        },
                        properties: element.tags,
                    };
                }
            }
            return null; // Return null for unsupported types
        }

        /**
         * Calculates the total length of a LineString GeoJSON object.
         * 
         * @param {Object} geoJsonLineString - A GeoJSON LineString feature.
         * @returns {number} - The total length in meters.
         */
        function calculateLineStringLengthInYards(geoJsonLineString) {
            // Ensure the GeoJSON is of type LineString
            if (geoJsonLineString.type !== 'Feature' ||
                geoJsonLineString.geometry.type !== 'LineString') {
                throw new Error('Invalid GeoJSON object. Must be a LineString.');
            }

            let coordinates = geoJsonLineString.geometry.coordinates; // Get the coordinates
            let totalDistance = 0;

            // Loop through the coordinates to calculate the distance
            for (let i = 0; i < coordinates.length - 1; i++) {
                let point1 = L.latLng(coordinates[i][1], coordinates[i][0]); // Create LatLng for point1
                let point2 = L.latLng(coordinates[i + 1][1], coordinates[i + 1][0]); // Create LatLng for point2
                totalDistance += point1.distanceTo(point2); // Add distance between points
            }

            return totalDistance * 1.09361; // Total length in yard (multiplied from meters)
        }

        // Helper function to get the midpoint of a line
        function getMidpoint(coordinates) {
            // const midIndex = Math.floor(coordinates.length / 2);
            return [coordinates[coordinates.length - 1][1], coordinates[coordinates.length - 1][0]]; // [lng, lat]
        }

        function onLocationFound(e) {
            const location = document.getElementById("location").value;
            const courseName = document.getElementById("courseName").value;
            if (!location) {
                queryForGolfCourses([convertLocationToObjectWithBBox(e, 0.1)], courseName);
            }
        }


        function convertLocationToObjectWithBBox(position, bboxSize = 0.05) {

            const lat = position.latitude;
            const lng = position.longitude;

            const locationWithBBox = {
                bbox:
                    L.latLngBounds(
                        [lat - bboxSize, lng - bboxSize],
                        [lat + bboxSize, lng + bboxSize]
                    )
            };

            return locationWithBBox;
        }

    </script>
</body>

</html>
